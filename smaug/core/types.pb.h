// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: smaug/core/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_smaug_2fcore_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_smaug_2fcore_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_smaug_2fcore_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_smaug_2fcore_2ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_smaug_2fcore_2ftypes_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace smaug {

enum DataType : int {
  UnknownDataType = 0,
  Int32 = 1,
  Int64 = 2,
  Float16 = 3,
  Float32 = 4,
  Float64 = 5,
  Bool = 6,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = UnknownDataType;
constexpr DataType DataType_MAX = Bool;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    const std::string& name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum DataLayout : int {
  UnknownLayout = 0,
  NCHW = 1,
  NHWC = 2,
  NC = 4,
  CN = 8,
  NCT = 16,
  NTC = 32,
  N = 64,
  X = 127,
  EndDataLayout = 64,
  DataLayout_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataLayout_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataLayout_IsValid(int value);
constexpr DataLayout DataLayout_MIN = UnknownLayout;
constexpr DataLayout DataLayout_MAX = X;
constexpr int DataLayout_ARRAYSIZE = DataLayout_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataLayout_descriptor();
template<typename T>
inline const std::string& DataLayout_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataLayout>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataLayout_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataLayout_descriptor(), enum_t_value);
}
inline bool DataLayout_Parse(
    const std::string& name, DataLayout* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataLayout>(
    DataLayout_descriptor(), name, value);
}
enum DataStorageFormat : int {
  UnknownStorageFormat = 0,
  Uncompressed = 1,
  CSR = 2,
  PackedCSR = 3,
  UncompressedHalfPrecision = 4,
  DataStorageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataStorageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataStorageFormat_IsValid(int value);
constexpr DataStorageFormat DataStorageFormat_MIN = UnknownStorageFormat;
constexpr DataStorageFormat DataStorageFormat_MAX = UncompressedHalfPrecision;
constexpr int DataStorageFormat_ARRAYSIZE = DataStorageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataStorageFormat_descriptor();
template<typename T>
inline const std::string& DataStorageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataStorageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataStorageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataStorageFormat_descriptor(), enum_t_value);
}
inline bool DataStorageFormat_Parse(
    const std::string& name, DataStorageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataStorageFormat>(
    DataStorageFormat_descriptor(), name, value);
}
enum OpType : int {
  UnknownOp = 0,
  Convolution3d = 1,
  ConvolutionDepthwise = 2,
  MaxPooling = 3,
  AveragePooling = 4,
  InnerProduct = 5,
  BatchNorm = 6,
  Data = 7,
  ReLU = 8,
  LReLU = 9,
  ELU = 10,
  SELU = 11,
  Tanh = 12,
  HardTanh = 13,
  Sigmoid = 14,
  Softmax = 15,
  EltwiseAdd = 16,
  Reorder = 17,
  EltwiseMul = 18,
  Concat = 19,
  Split = 20,
  Reshape = 21,
  Repeat = 22,
  Less = 23,
  LessEqual = 24,
  Greater = 25,
  GreaterEqual = 26,
  Switch = 27,
  Merge = 28,
  Padding = 29,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OpType_IsValid(int value);
constexpr OpType OpType_MIN = UnknownOp;
constexpr OpType OpType_MAX = Padding;
constexpr int OpType_ARRAYSIZE = OpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpType_descriptor();
template<typename T>
inline const std::string& OpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpType_descriptor(), enum_t_value);
}
inline bool OpType_Parse(
    const std::string& name, OpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpType>(
    OpType_descriptor(), name, value);
}
enum PaddingType : int {
  UnknownPadding = 0,
  SamePadding = 1,
  ValidPadding = 2,
  PaddingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaddingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaddingType_IsValid(int value);
constexpr PaddingType PaddingType_MIN = UnknownPadding;
constexpr PaddingType PaddingType_MAX = ValidPadding;
constexpr int PaddingType_ARRAYSIZE = PaddingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaddingType_descriptor();
template<typename T>
inline const std::string& PaddingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaddingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaddingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaddingType_descriptor(), enum_t_value);
}
inline bool PaddingType_Parse(
    const std::string& name, PaddingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaddingType>(
    PaddingType_descriptor(), name, value);
}
enum HostMemoryAccessPolicy : int {
  UnknownMemoryPolicy = 0,
  AllDma = 1,
  AllAcp = 2,
  AllAcpWithDmaForWeights = 4,
  HostMemoryAccessPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HostMemoryAccessPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HostMemoryAccessPolicy_IsValid(int value);
constexpr HostMemoryAccessPolicy HostMemoryAccessPolicy_MIN = UnknownMemoryPolicy;
constexpr HostMemoryAccessPolicy HostMemoryAccessPolicy_MAX = AllAcpWithDmaForWeights;
constexpr int HostMemoryAccessPolicy_ARRAYSIZE = HostMemoryAccessPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HostMemoryAccessPolicy_descriptor();
template<typename T>
inline const std::string& HostMemoryAccessPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HostMemoryAccessPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HostMemoryAccessPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HostMemoryAccessPolicy_descriptor(), enum_t_value);
}
inline bool HostMemoryAccessPolicy_Parse(
    const std::string& name, HostMemoryAccessPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HostMemoryAccessPolicy>(
    HostMemoryAccessPolicy_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace smaug

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::smaug::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::smaug::DataType>() {
  return ::smaug::DataType_descriptor();
}
template <> struct is_proto_enum< ::smaug::DataLayout> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::smaug::DataLayout>() {
  return ::smaug::DataLayout_descriptor();
}
template <> struct is_proto_enum< ::smaug::DataStorageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::smaug::DataStorageFormat>() {
  return ::smaug::DataStorageFormat_descriptor();
}
template <> struct is_proto_enum< ::smaug::OpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::smaug::OpType>() {
  return ::smaug::OpType_descriptor();
}
template <> struct is_proto_enum< ::smaug::PaddingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::smaug::PaddingType>() {
  return ::smaug::PaddingType_descriptor();
}
template <> struct is_proto_enum< ::smaug::HostMemoryAccessPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::smaug::HostMemoryAccessPolicy>() {
  return ::smaug::HostMemoryAccessPolicy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_smaug_2fcore_2ftypes_2eproto
